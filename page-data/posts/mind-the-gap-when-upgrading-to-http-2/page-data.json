{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/mind-the-gap-when-upgrading-to-http-2/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://www.polvara.me"}},"markdownRemark":{"html":"<p>The web has been in great ferment in the last few years. HTML 5, ECMAScript 2015\nand all the new landing features are making our beloved platform a great place\nto be.</p>\n<p>One of the most significant improvements is HTTP/2.</p>\n<p>The <em>Hypertext Transfer Protocol</em> evolved a lot since its beginnings in 1989.\nWhen Tim Berners-Lee and his team created the protocol, they needed only a few\nfeatures.</p>\n<p>This first version was simple: it allowed only to perform GET requests and\nreceive HTML data. Over the years, the <a href=\"https://httpwg.github.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HTTP WG</a>\ndocumented and updated the protocol bringing it to version 1.1.</p>\n<p>Although most of the web runs on HTTP/1.1, this version has many issues.\nUpdating a protocol, especially if highly adopted, is not an easy task. For this\nreason, developers had to create workarounds to many problems.</p>\n<p>If you are a web developer you know most of them and chances are you’re using\nthem in your projects.</p>\n<p>All those best practices are helpful but become counterproductive when used\nalongside with HTTP/2. Let’s analyze them and see why is this the case.</p>\n<h2>Domain Sharding</h2>\n<p>When we start an HTTP/1.x request, a new TCP connection is created. Once the\nrequest ends, we can reutilize the connection so we don’t have to create a new\none.</p>\n<p>This mechanism was serving us well during the early web but, with the time, we\noutgrew it. A web page is no longer one single HTML file; we require CSS,\nJavaScript and images.</p>\n<p>For this reason, browsers started handling a connection pool of TCP streams.\nModern browsers usually support six streams per host. This means that, if your\npage requires six images, the browser can download them in parallel. As you can\nimagine, it is a great performance boost.</p>\n<p>Even so, with the average web page asking for 90+ resources, this is still not\nenough. Many requests will wait in queue before getting served.</p>\n<p>Developers created a workaround to this problem: <em>domain sharding</em>. If a\nbrowsers’ limit is six TCP connections per host, we can put our assets on\ndifferent hosts. That is, if our domain is <em>example.com</em>, images can be hosted\nat <em>images.example.com</em> and CSS files at <em>css.example.com</em>. In this way the\nbrowser will open six parallel connections for your images and six for your CSS\nfiles. Note that usually these subdomains are just CNAME DNS records that point\nto the same IP address.</p>\n<p>The browser will have to resolve each DNS name but you get a good performance\nboost.</p>\n<p><em>If you decide to upgrade to HTTP/2 you should disable domain sharding.</em></p>\n<p>HTTP/2 creates only one TCP connection and uses it to the fullest extent. The\nstream can provide full <a href=\"https://en.wikipedia.org/wiki/Multiplexing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">multiplex</a>\nsupport, both while sending and receiving. For this reason, clients no longer\nneed to initiate more TCP connections at the same time. However, if we host our\nassets on different domains, the browser will have to create a new TCP\nconnection. This not only means more DNS requests. With HTTP/2 headers are sent\nonly when we first set them and when we want to change them, saving precious\nbytes. Connecting to more than one host means sending the headers more than\nonce. Last, the client can prioritize the requests to receive the most important\ndata first. If we use domain sharding this option is less effective.</p>\n<h2>Concatenation and Spriting</h2>\n<p>When you make a HTTP request you wait, at a minimum, for a full roundtrip of\nlatency before you get the first data back. For the average webpage this means a\nlot of extra loading time. One obvious piece of advice here is “Don’t make a\nrequest unless you need it”. Another way to speed-up the loading process is to\njoin together the resources you need.</p>\n<p>When you join text files, usually JavaScript and CSS, we say we concatenate\nthem.</p>\n<p>On the other hand, for images, we generate an <em>image sprite</em>. That is, an image\nthat contains more images. Using CSS we can then display only the part of the\nimage we need.</p>\n<p>Both techniques allow us to generate less requests. Instead of 20 separate CSS\nfiles we load just one that contains all others.</p>\n<p>There are also downsides. Your page may not need all the data you concatenate\nresulting in a waste of bandwidth. Also, if one of your assets changes, you\nforce the user to invalidate the cache and download it again. Last, your\nJavaScript and CSS files will not get executed until the browser has finished to\ndownloading them.</p>\n<p>All in all, for many applications running over HTTP/1.x, concatenation and\nspriting is a good solution.</p>\n<p>However, this is not true for HTTP/2, since many small resources can be\ndownloaded in parallel. In this case, the downsides of concatenating exceed its\nbenefits.</p>\n<p>Another feature in HTTP/2 is the ability for the server to push data to the\nclient. When this happens, the browser will simply store the data in its cache.\nLater, when that resource is needed, it can be fetched from the cache. This\nmakes concatenating even less necessary. We can instruct the server to push all\nthese little assets, giving them priority.</p>\n<h2>Conclusions</h2>\n<p>HTTP/2\n<a href=\"http://caniuse.com/#feat=http2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">is currently supported by most web browsers</a>.\nAlthough a decade will pass before the majority of the web upgrades to it. Even\nso, you should plan your upgrade path now. The benefits you’ll get from it are\ndefinitely worth it. Just remeber to question all the best practices you learned\nthrough the years.</p>","timeToRead":4,"frontmatter":{"title":"Mind the Gap when upgrading to HTTP/2","cover":{"file":{"publicURL":"/static/f795dffe5603fdb30b6407753421ec59/cover.jpg"},"author":"Erez Attias","link":"https://unsplash.com/photos/KqVHRmHVwwM","alt":null}},"fields":{"slug":"/posts/mind-the-gap-when-upgrading-to-http-2/"}}},"pageContext":{"slug":"/posts/mind-the-gap-when-upgrading-to-http-2/"}}}